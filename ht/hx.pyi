# DO NOT EDIT - AUTOMATICALLY GENERATED BY tests/make_test_stubs.py!
from typing import List
from numpy import float64
from typing import (
    Callable,
    Dict,
    List,
    Optional,
    Union,
)


def DBundle_for_Ntubes_HEDH(N: int, Do: float, pitch: float, angle: int = ...) -> float: ...


def DBundle_for_Ntubes_Phadkeb(Ntubes: int, Do: float, pitch: float, Ntp: int, angle: int = ...) -> float64: ...


def DBundle_min(Do: float) -> float: ...


def D_for_Ntubes_VDI(N: int, Ntp: float, Do: float, pitch: float, angle: float = ...) -> float: ...


def F_LMTD_Fakheri(Thi: int, Tho: float, Tci: int, Tco: float, shells: int = ...) -> float: ...


def L_unsupported_max(Do: float, material: str = ...) -> float: ...


def NTU_from_P_E(P1: float, R1: float, Ntp: int, optimal: bool = ...) -> float: ...


def NTU_from_P_G(P1: float, R1: float, Ntp: int, optimal: bool = ...) -> float: ...


def NTU_from_P_H(P1: float, R1: float, Ntp: int, optimal: bool = ...) -> float: ...


def NTU_from_P_J(P1: float, R1: float, Ntp: int) -> float: ...


def NTU_from_P_basic(
    P1: Union[float64, float],
    R1: Union[float64, float],
    subtype: str = ...
) -> Union[float64, float]: ...


def NTU_from_P_plate(
    P1: float,
    R1: float,
    Np1: int,
    Np2: int,
    counterflow: bool = ...,
    passes_counterflow: bool = ...,
    reverse: bool = ...
) -> float: ...


def NTU_from_UA(UA: float, Cmin: float) -> float: ...


def NTU_from_effectiveness(effectiveness: float, Cr: float, subtype: str = ...) -> float: ...


def Ntubes(
    DBundle: float,
    Do: float,
    pitch: float,
    Ntp: int = ...,
    angle: int = ...,
    Method: Optional[str] = ...
) -> int: ...


def Ntubes_HEDH(
    DBundle: Optional[float] = ...,
    Do: Optional[float] = ...,
    pitch: Optional[float] = ...,
    angle: int = ...
) -> int: ...


def Ntubes_Perrys(DBundle: float, Do: float, Ntp: int, angle: int = ...) -> int: ...


def Ntubes_Phadkeb(
    DBundle: Union[int, float64, float],
    Do: float,
    pitch: float,
    Ntp: int,
    angle: float = ...
) -> int: ...


def Ntubes_VDI(
    DBundle: Optional[float] = ...,
    Ntp: Optional[int] = ...,
    Do: Optional[float] = ...,
    pitch: Optional[float] = ...,
    angle: int = ...
) -> int: ...


def P_NTU_method(
    m1: float,
    m2: float,
    Cp1: float,
    Cp2: float,
    UA: Optional[float] = ...,
    T1i: Optional[int] = ...,
    T1o: Optional[float] = ...,
    T2i: Optional[int] = ...,
    T2o: Optional[int] = ...,
    subtype: str = ...,
    Ntp: int = ...,
    optimal: bool = ...
) -> Dict[str, float]: ...


def Pc(x: float, y: float) -> float: ...


def Pp(x: float, y: float) -> float: ...


def UA_from_NTU(NTU: float, Cmin: float) -> float: ...


def _NTU_from_P_erf(NTU1: Union[int, float64, float], *args) -> Union[float64, float]: ...


def _NTU_from_P_solver(
    P1: Union[float64, float],
    R1: Union[float64, float],
    NTU_min: Optional[float],
    NTU_max: Optional[Union[int, float64, float]],
    function: Callable,
    guess: Optional[float],
    *args
) -> Union[int, float64, float]: ...


def _NTU_max_for_P_solver(
    ps: List[List[float]],
    qs: List[List[float]],
    offsets: List[float],
    R1: Union[float64, float]
) -> Union[float64, float]: ...


def _load_coeffs_Phadkeb() -> None: ...


def _tubecount_objf_Perry(D: float, Do: float, Ntp: int, angle: int, N: int) -> int: ...


def calc_Cmax(mh: float, mc: float, Cph: float, Cpc: int) -> float: ...


def calc_Cmin(mh: float, mc: float, Cph: float, Cpc: int) -> float: ...


def calc_Cr(mh: float, mc: float, Cph: float, Cpc: int) -> float: ...


def crossflow_effectiveness_to_int(v: float, NTU: float, t0: float) -> float: ...


def effectiveness_NTU_method(
    mh: float,
    mc: float,
    Cph: float,
    Cpc: int,
    subtype: str = ...,
    Thi: Optional[int] = ...,
    Tho: Optional[float] = ...,
    Tci: Optional[int] = ...,
    Tco: Optional[int] = ...,
    UA: Optional[float] = ...
) -> Dict[str, float]: ...


def effectiveness_from_NTU(NTU: float, Cr: float, subtype: str = ...) -> float: ...


def shell_clearance(DBundle: Optional[float] = ..., DShell: Optional[float] = ...) -> float: ...


def size_bundle_from_tubecount(
    N: int,
    Do: float,
    pitch: float,
    Ntp: int = ...,
    angle: int = ...,
    Method: Optional[str] = ...
) -> Union[float64, float]: ...


def temperature_effectiveness_TEMA_E(
    R1: float,
    NTU1: float,
    Ntp: int = ...,
    optimal: bool = ...
) -> float: ...


def temperature_effectiveness_TEMA_G(
    R1: float,
    NTU1: float,
    Ntp: int,
    optimal: bool = ...
) -> float: ...


def temperature_effectiveness_TEMA_H(
    R1: float,
    NTU1: float,
    Ntp: int,
    optimal: bool = ...
) -> float: ...


def temperature_effectiveness_TEMA_J(R1: float, NTU1: float, Ntp: int) -> float: ...


def temperature_effectiveness_air_cooler(
    R1: float,
    NTU1: float,
    rows: int,
    passes: int,
    coerce: bool = ...
) -> float: ...


def temperature_effectiveness_basic(
    R1: Union[float64, float],
    NTU1: Union[int, float64, float],
    subtype: str = ...
) -> Union[float64, float]: ...


def temperature_effectiveness_plate(
    R1: float,
    NTU1: float,
    Np1: int,
    Np2: int,
    counterflow: bool = ...,
    passes_counterflow: bool = ...,
    reverse: bool = ...
) -> float: ...


def to_solve_Ntubes_Phadkeb(
    DBundle: Union[int, float64],
    Do: float,
    pitch: float,
    Ntp: int,
    angle: int,
    Ntubes: int
) -> int: ...

__all__: List[str]